/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

type ErrorWithCode = Error & { code: number }
type MaybeErrorWithCode = ErrorWithCode | null | undefined

const createErrorFromCodeLookup: Map<number, () => ErrorWithCode> = new Map()
const createErrorFromNameLookup: Map<string, () => ErrorWithCode> = new Map()

/**
 * BadDescriptionSetting: 'The description provided is not a description setting'
 *
 * @category Errors
 * @category generated
 */
export class BadDescriptionSettingError extends Error {
  readonly code: number = 0x1770
  readonly name: string = 'BadDescriptionSetting'
  constructor() {
    super('The description provided is not a description setting')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, BadDescriptionSettingError)
    }
  }
}

createErrorFromCodeLookup.set(0x1770, () => new BadDescriptionSettingError())
createErrorFromNameLookup.set(
  'BadDescriptionSetting',
  () => new BadDescriptionSettingError()
)

/**
 * BadVoteRestrictionSetting: 'The vote restriction provided is not a vote restriction setting'
 *
 * @category Errors
 * @category generated
 */
export class BadVoteRestrictionSettingError extends Error {
  readonly code: number = 0x1771
  readonly name: string = 'BadVoteRestrictionSetting'
  constructor() {
    super('The vote restriction provided is not a vote restriction setting')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, BadVoteRestrictionSettingError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x1771,
  () => new BadVoteRestrictionSettingError()
)
createErrorFromNameLookup.set(
  'BadVoteRestrictionSetting',
  () => new BadVoteRestrictionSettingError()
)

/**
 * ProposalIdTooLarge: 'The provided proposal ID is too large an increase'
 *
 * @category Errors
 * @category generated
 */
export class ProposalIdTooLargeError extends Error {
  readonly code: number = 0x17d4
  readonly name: string = 'ProposalIdTooLarge'
  constructor() {
    super('The provided proposal ID is too large an increase')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ProposalIdTooLargeError)
    }
  }
}

createErrorFromCodeLookup.set(0x17d4, () => new ProposalIdTooLargeError())
createErrorFromNameLookup.set(
  'ProposalIdTooLarge',
  () => new ProposalIdTooLargeError()
)

/**
 * NotTokenAccount: 'The provided token account is not a token account'
 *
 * @category Errors
 * @category generated
 */
export class NotTokenAccountError extends Error {
  readonly code: number = 0x1838
  readonly name: string = 'NotTokenAccount'
  constructor() {
    super('The provided token account is not a token account')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NotTokenAccountError)
    }
  }
}

createErrorFromCodeLookup.set(0x1838, () => new NotTokenAccountError())
createErrorFromNameLookup.set(
  'NotTokenAccount',
  () => new NotTokenAccountError()
)

/**
 * MissingTokenRestriction: 'Missing the token required by the restriction'
 *
 * @category Errors
 * @category generated
 */
export class MissingTokenRestrictionError extends Error {
  readonly code: number = 0x1839
  readonly name: string = 'MissingTokenRestriction'
  constructor() {
    super('Missing the token required by the restriction')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MissingTokenRestrictionError)
    }
  }
}

createErrorFromCodeLookup.set(0x1839, () => new MissingTokenRestrictionError())
createErrorFromNameLookup.set(
  'MissingTokenRestriction',
  () => new MissingTokenRestrictionError()
)

/**
 * InvalidMetadataKey: 'Account provided is not expected metadata key'
 *
 * @category Errors
 * @category generated
 */
export class InvalidMetadataKeyError extends Error {
  readonly code: number = 0x183a
  readonly name: string = 'InvalidMetadataKey'
  constructor() {
    super('Account provided is not expected metadata key')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidMetadataKeyError)
    }
  }
}

createErrorFromCodeLookup.set(0x183a, () => new InvalidMetadataKeyError())
createErrorFromNameLookup.set(
  'InvalidMetadataKey',
  () => new InvalidMetadataKeyError()
)

/**
 * MetadataAccountInvalid: 'The provided account is not a metadata account'
 *
 * @category Errors
 * @category generated
 */
export class MetadataAccountInvalidError extends Error {
  readonly code: number = 0x183b
  readonly name: string = 'MetadataAccountInvalid'
  constructor() {
    super('The provided account is not a metadata account')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MetadataAccountInvalidError)
    }
  }
}

createErrorFromCodeLookup.set(0x183b, () => new MetadataAccountInvalidError())
createErrorFromNameLookup.set(
  'MetadataAccountInvalid',
  () => new MetadataAccountInvalidError()
)

/**
 * NoCollectionOnMetadata: 'No collection set on the metadata'
 *
 * @category Errors
 * @category generated
 */
export class NoCollectionOnMetadataError extends Error {
  readonly code: number = 0x183c
  readonly name: string = 'NoCollectionOnMetadata'
  constructor() {
    super('No collection set on the metadata')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NoCollectionOnMetadataError)
    }
  }
}

createErrorFromCodeLookup.set(0x183c, () => new NoCollectionOnMetadataError())
createErrorFromNameLookup.set(
  'NoCollectionOnMetadata',
  () => new NoCollectionOnMetadataError()
)

/**
 * MissingCollectionNftRestriction: 'Missing an NFT from the collection required by the restriction'
 *
 * @category Errors
 * @category generated
 */
export class MissingCollectionNftRestrictionError extends Error {
  readonly code: number = 0x183d
  readonly name: string = 'MissingCollectionNftRestriction'
  constructor() {
    super('Missing an NFT from the collection required by the restriction')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MissingCollectionNftRestrictionError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x183d,
  () => new MissingCollectionNftRestrictionError()
)
createErrorFromNameLookup.set(
  'MissingCollectionNftRestriction',
  () => new MissingCollectionNftRestrictionError()
)

/**
 * MalformedSetting: 'Cannot parse a setting'
 *
 * @category Errors
 * @category generated
 */
export class MalformedSettingError extends Error {
  readonly code: number = 0x183e
  readonly name: string = 'MalformedSetting'
  constructor() {
    super('Cannot parse a setting')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MalformedSettingError)
    }
  }
}

createErrorFromCodeLookup.set(0x183e, () => new MalformedSettingError())
createErrorFromNameLookup.set(
  'MalformedSetting',
  () => new MalformedSettingError()
)

/**
 * InvalidRestrictionExtraAccounts: 'Extra account offsets invalid for this restriction type'
 *
 * @category Errors
 * @category generated
 */
export class InvalidRestrictionExtraAccountsError extends Error {
  readonly code: number = 0x183f
  readonly name: string = 'InvalidRestrictionExtraAccounts'
  constructor() {
    super('Extra account offsets invalid for this restriction type')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, InvalidRestrictionExtraAccountsError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x183f,
  () => new InvalidRestrictionExtraAccountsError()
)
createErrorFromNameLookup.set(
  'InvalidRestrictionExtraAccounts',
  () => new InvalidRestrictionExtraAccountsError()
)

/**
 * MissingRequiredOffsets: 'Must supply offsets when a proposal restriction applies'
 *
 * @category Errors
 * @category generated
 */
export class MissingRequiredOffsetsError extends Error {
  readonly code: number = 0x1840
  readonly name: string = 'MissingRequiredOffsets'
  constructor() {
    super('Must supply offsets when a proposal restriction applies')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MissingRequiredOffsetsError)
    }
  }
}

createErrorFromCodeLookup.set(0x1840, () => new MissingRequiredOffsetsError())
createErrorFromNameLookup.set(
  'MissingRequiredOffsets',
  () => new MissingRequiredOffsetsError()
)

/**
 * AlreadyVoted: 'Already voted on this proposal'
 *
 * @category Errors
 * @category generated
 */
export class AlreadyVotedError extends Error {
  readonly code: number = 0x1841
  readonly name: string = 'AlreadyVoted'
  constructor() {
    super('Already voted on this proposal')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, AlreadyVotedError)
    }
  }
}

createErrorFromCodeLookup.set(0x1841, () => new AlreadyVotedError())
createErrorFromNameLookup.set('AlreadyVoted', () => new AlreadyVotedError())

/**
 * MissingCredentials: 'Missing a required credential for proposal restriction'
 *
 * @category Errors
 * @category generated
 */
export class MissingCredentialsError extends Error {
  readonly code: number = 0x1842
  readonly name: string = 'MissingCredentials'
  constructor() {
    super('Missing a required credential for proposal restriction')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MissingCredentialsError)
    }
  }
}

createErrorFromCodeLookup.set(0x1842, () => new MissingCredentialsError())
createErrorFromNameLookup.set(
  'MissingCredentials',
  () => new MissingCredentialsError()
)

/**
 * MultipleProposalIds: 'Cannot vote on a proposal with different proposal ids'
 *
 * @category Errors
 * @category generated
 */
export class MultipleProposalIdsError extends Error {
  readonly code: number = 0x1843
  readonly name: string = 'MultipleProposalIds'
  constructor() {
    super('Cannot vote on a proposal with different proposal ids')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MultipleProposalIdsError)
    }
  }
}

createErrorFromCodeLookup.set(0x1843, () => new MultipleProposalIdsError())
createErrorFromNameLookup.set(
  'MultipleProposalIds',
  () => new MultipleProposalIdsError()
)

/**
 * MultipleSameVotedFor: 'Cannot vote on an option more than once'
 *
 * @category Errors
 * @category generated
 */
export class MultipleSameVotedForError extends Error {
  readonly code: number = 0x1844
  readonly name: string = 'MultipleSameVotedFor'
  constructor() {
    super('Cannot vote on an option more than once')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MultipleSameVotedForError)
    }
  }
}

createErrorFromCodeLookup.set(0x1844, () => new MultipleSameVotedForError())
createErrorFromNameLookup.set(
  'MultipleSameVotedFor',
  () => new MultipleSameVotedForError()
)

/**
 * TooManyEntriesSelected: 'Cannot vote for more than max allowed'
 *
 * @category Errors
 * @category generated
 */
export class TooManyEntriesSelectedError extends Error {
  readonly code: number = 0x1845
  readonly name: string = 'TooManyEntriesSelected'
  constructor() {
    super('Cannot vote for more than max allowed')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TooManyEntriesSelectedError)
    }
  }
}

createErrorFromCodeLookup.set(0x1845, () => new TooManyEntriesSelectedError())
createErrorFromNameLookup.set(
  'TooManyEntriesSelected',
  () => new TooManyEntriesSelectedError()
)

/**
 * MissingSigner: 'There must be a signer present for this instruction'
 *
 * @category Errors
 * @category generated
 */
export class MissingSignerError extends Error {
  readonly code: number = 0x1846
  readonly name: string = 'MissingSigner'
  constructor() {
    super('There must be a signer present for this instruction')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, MissingSignerError)
    }
  }
}

createErrorFromCodeLookup.set(0x1846, () => new MissingSignerError())
createErrorFromNameLookup.set('MissingSigner', () => new MissingSignerError())

/**
 * DuplicateVoteOptionIds: 'Vote option IDs must be unique'
 *
 * @category Errors
 * @category generated
 */
export class DuplicateVoteOptionIdsError extends Error {
  readonly code: number = 0x1847
  readonly name: string = 'DuplicateVoteOptionIds'
  constructor() {
    super('Vote option IDs must be unique')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, DuplicateVoteOptionIdsError)
    }
  }
}

createErrorFromCodeLookup.set(0x1847, () => new DuplicateVoteOptionIdsError())
createErrorFromNameLookup.set(
  'DuplicateVoteOptionIds',
  () => new DuplicateVoteOptionIdsError()
)

/**
 * ProposalClosed: 'Proposal is closed for voting'
 *
 * @category Errors
 * @category generated
 */
export class ProposalClosedError extends Error {
  readonly code: number = 0x1848
  readonly name: string = 'ProposalClosed'
  constructor() {
    super('Proposal is closed for voting')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ProposalClosedError)
    }
  }
}

createErrorFromCodeLookup.set(0x1848, () => new ProposalClosedError())
createErrorFromNameLookup.set('ProposalClosed', () => new ProposalClosedError())

/**
 * ProposalCannotBeClosed: 'Cannot close proposal for voting'
 *
 * @category Errors
 * @category generated
 */
export class ProposalCannotBeClosedError extends Error {
  readonly code: number = 0x1849
  readonly name: string = 'ProposalCannotBeClosed'
  constructor() {
    super('Cannot close proposal for voting')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, ProposalCannotBeClosedError)
    }
  }
}

createErrorFromCodeLookup.set(0x1849, () => new ProposalCannotBeClosedError())
createErrorFromNameLookup.set(
  'ProposalCannotBeClosed',
  () => new ProposalCannotBeClosedError()
)

/**
 * NotVotebankOwner: 'Not a votebank owner'
 *
 * @category Errors
 * @category generated
 */
export class NotVotebankOwnerError extends Error {
  readonly code: number = 0x184a
  readonly name: string = 'NotVotebankOwner'
  constructor() {
    super('Not a votebank owner')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, NotVotebankOwnerError)
    }
  }
}

createErrorFromCodeLookup.set(0x184a, () => new NotVotebankOwnerError())
createErrorFromNameLookup.set(
  'NotVotebankOwner',
  () => new NotVotebankOwnerError()
)

/**
 * OwnerAlreadyExists: 'Already owner of the votebank'
 *
 * @category Errors
 * @category generated
 */
export class OwnerAlreadyExistsError extends Error {
  readonly code: number = 0x184b
  readonly name: string = 'OwnerAlreadyExists'
  constructor() {
    super('Already owner of the votebank')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, OwnerAlreadyExistsError)
    }
  }
}

createErrorFromCodeLookup.set(0x184b, () => new OwnerAlreadyExistsError())
createErrorFromNameLookup.set(
  'OwnerAlreadyExists',
  () => new OwnerAlreadyExistsError()
)

/**
 * OwnerNotFound: 'Owner on votebank does not exist'
 *
 * @category Errors
 * @category generated
 */
export class OwnerNotFoundError extends Error {
  readonly code: number = 0x184c
  readonly name: string = 'OwnerNotFound'
  constructor() {
    super('Owner on votebank does not exist')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, OwnerNotFoundError)
    }
  }
}

createErrorFromCodeLookup.set(0x184c, () => new OwnerNotFoundError())
createErrorFromNameLookup.set('OwnerNotFound', () => new OwnerNotFoundError())

/**
 * LastOwnerCannotBeRemoved: 'There needs to be at least one owner'
 *
 * @category Errors
 * @category generated
 */
export class LastOwnerCannotBeRemovedError extends Error {
  readonly code: number = 0x184d
  readonly name: string = 'LastOwnerCannotBeRemoved'
  constructor() {
    super('There needs to be at least one owner')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, LastOwnerCannotBeRemovedError)
    }
  }
}

createErrorFromCodeLookup.set(0x184d, () => new LastOwnerCannotBeRemovedError())
createErrorFromNameLookup.set(
  'LastOwnerCannotBeRemoved',
  () => new LastOwnerCannotBeRemovedError()
)

/**
 * TooManyDelegateAddresses: 'You can only delegate 5 addresses'
 *
 * @category Errors
 * @category generated
 */
export class TooManyDelegateAddressesError extends Error {
  readonly code: number = 0x184e
  readonly name: string = 'TooManyDelegateAddresses'
  constructor() {
    super('You can only delegate 5 addresses')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, TooManyDelegateAddressesError)
    }
  }
}

createErrorFromCodeLookup.set(0x184e, () => new TooManyDelegateAddressesError())
createErrorFromNameLookup.set(
  'TooManyDelegateAddresses',
  () => new TooManyDelegateAddressesError()
)

/**
 * DelegateAddressNotFound: 'Signer not found in delegate addresses'
 *
 * @category Errors
 * @category generated
 */
export class DelegateAddressNotFoundError extends Error {
  readonly code: number = 0x184f
  readonly name: string = 'DelegateAddressNotFound'
  constructor() {
    super('Signer not found in delegate addresses')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, DelegateAddressNotFoundError)
    }
  }
}

createErrorFromCodeLookup.set(0x184f, () => new DelegateAddressNotFoundError())
createErrorFromNameLookup.set(
  'DelegateAddressNotFound',
  () => new DelegateAddressNotFoundError()
)

/**
 * DuplicateDelegateAddresses: 'Duplicate delegate addresses found'
 *
 * @category Errors
 * @category generated
 */
export class DuplicateDelegateAddressesError extends Error {
  readonly code: number = 0x1850
  readonly name: string = 'DuplicateDelegateAddresses'
  constructor() {
    super('Duplicate delegate addresses found')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, DuplicateDelegateAddressesError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x1850,
  () => new DuplicateDelegateAddressesError()
)
createErrorFromNameLookup.set(
  'DuplicateDelegateAddresses',
  () => new DuplicateDelegateAddressesError()
)

/**
 * DelegateAddressAlreadySigned: 'Delegate address cannot be signed on creation'
 *
 * @category Errors
 * @category generated
 */
export class DelegateAddressAlreadySignedError extends Error {
  readonly code: number = 0x1851
  readonly name: string = 'DelegateAddressAlreadySigned'
  constructor() {
    super('Delegate address cannot be signed on creation')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, DelegateAddressAlreadySignedError)
    }
  }
}

createErrorFromCodeLookup.set(
  0x1851,
  () => new DelegateAddressAlreadySignedError()
)
createErrorFromNameLookup.set(
  'DelegateAddressAlreadySigned',
  () => new DelegateAddressAlreadySignedError()
)

/**
 * CannotAddSelfAsDelegate: 'Cannot add self as delegate'
 *
 * @category Errors
 * @category generated
 */
export class CannotAddSelfAsDelegateError extends Error {
  readonly code: number = 0x1852
  readonly name: string = 'CannotAddSelfAsDelegate'
  constructor() {
    super('Cannot add self as delegate')
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(this, CannotAddSelfAsDelegateError)
    }
  }
}

createErrorFromCodeLookup.set(0x1852, () => new CannotAddSelfAsDelegateError())
createErrorFromNameLookup.set(
  'CannotAddSelfAsDelegate',
  () => new CannotAddSelfAsDelegateError()
)

/**
 * Attempts to resolve a custom program error from the provided error code.
 * @category Errors
 * @category generated
 */
export function errorFromCode(code: number): MaybeErrorWithCode {
  const createError = createErrorFromCodeLookup.get(code)
  return createError != null ? createError() : null
}

/**
 * Attempts to resolve a custom program error from the provided error name, i.e. 'Unauthorized'.
 * @category Errors
 * @category generated
 */
export function errorFromName(name: string): MaybeErrorWithCode {
  const createError = createErrorFromNameLookup.get(name)
  return createError != null ? createError() : null
}
